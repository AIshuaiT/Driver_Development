【0】驱动8天安排：
	前四天：
  1-- 模块概念、字符设备驱动框架
  2-- 字符设备驱动框架2、并发控制
  3-- IO模型底层实现、中断系统
  4-- 内核的时间机制、内存访问、设备模型

	后四天：
     GPIO、中断、pwm、ADC、IIC ---- 必须掌握
     spi、块设备、网络设备     ---- 了解



=========================================================================
【1】模块
模块就是一段代码、可以随时添加或删除。 驱动中对应的就是.ko文件

【2】模块的优点
（1） 高效
（2） 灵活
（3） 规避版权管理


【3】可以写成模块的内容
（1）驱动
（2）网络协议
（3）文件系统


【4】               模块           和        应用程序
（1）运行空间     内核空间                   用户空间
（2）入口函数     加载函数                      main
（3）库函数调用   内核函数                  用户空间 /usr/lib /usr/include
（4）释放资源     必须回收                   要求释放，如果没有释放，还有系统回收


=========================================================================
【5】编写模块的三要素
（1）版权声明
     MODULE_LICENSE("GPL");


（2）加载函数
  1--缺省加载函数
     int init_module(void)
    {
       //申请资源
       return 0；
    }
   功能：在模块被加载时，自动运行，申请资源
   返回值：成返回0，失败返回-错误码
   注意：底层void不可以省


  2--自定义加载函数
   （1）定义一个和缺省加载函数同型的函数（只有函数名不同）
       自定义加载函数名； 模块名_init
                      hello_init

   （2）将自定义的 加载函数名 向内核声明成加载函数。
        module_init( 自定义加载函数名);


（3）卸载函数
  1-- 缺省卸载函数
     void cleanup_module(void)
    {
      //做和加载函数相反的卸载资源
    }
    功能：在模块被卸载时，自动运行，释放资源



   2--自定义卸载函数
   （1）定义一个和缺省卸载函数同型的函数（只有函数名不同）
        自定义卸载函数名： 模块名_exit
                           hello_exit
   （2）将自定义的 卸载函数名 向内核声明成卸载函数、
        module_exit( 自定义卸载函数名);


=========================================================================
【6】模块命令
（1）模块文件名称  xxx.ko 
     模块名称      xxx

（2）加载模块
     sudo insmod   xxx.ko


（3）卸载模块
     sudo  rmmod    xxx
 
（4）显示当前已经加载的模块
     lsmod
     定位查找
     lsmod | grep  xxx

（5）查看模块信息 modinfo  xxx.ko

（6）模块加载命令2 modprobe 和 insmod命令的不同
	1-- modprobe   加载内部模块
				   能够自动加载依赖模块
				   后面加模块名

	2-- insmod     能加载内部和外部模块
				   不能自动加载依赖模块
				   后面加模块文件名

查看当前模块是否为内部模块：modinfo    /   intree:      Y
查看当前模块的依赖模块    : modinfo     /   depends:        9pnet




【7】显示内核消息缓冲区的信息
     dmesg  ：显示内核缓冲区内容
     sudo  dmesg  -c：显示内核缓冲区内容并清除
     sudo  dmesg  -C：直接清除内存缓冲区的内容



=========================================================================
=======================================
			和模块编译相关：
=======================================
【8】内核模块的编译条件
（1）配置好的内核源码
（2）编译过的内核源码

【9】内核模块的使用条件
    编译内核模块的内核版本要和运行内核模块的内核版本要相同 
    运行内核版本：     uname   -r
    模块编译内核版本： modinfo xxx.ko

【10】模块编译类型
 （1）内部编译：把源码放到内核源码目录里进行编译。 ---- 内核源码顶级目录下的makefile
 （2）外部编译：把源码放到内核源码目录外进行编译。 ---- 外部的makefile



【11】外部编译makefile
（1）分析：看发的文档
（2）使用：
      1-- 指定内核源码的位置
         KERNELDIR ?= /lib/modules/$(shell uname -r)/build  
      2--指定目标要和源文件名称相同
             obj-m := 源文件.o


【12】__init 和 __exit
（1）__init 在静态编译时有意义：放在init段的指令段。在内核启动后，自动释放init段
（2）__exit 在静态编译时有意义：卸载函数不编译




=========================================================================
【13】模块传参
 （1）流程
     1-- 在模块源码内部定义一个变量，并初始化。

     2-- 用module_param宏来声明该变量可以接受传参。
         module_param(参数名,参数类型,参数读/写权限)；

     3-- 在加载模块时，传输参数
         sudo insmod  xxx.ko  p=200 

     4-- 可选，添加参数信息 用modinfo xxx.ko查看
         MODULE_PARM_DESC (myint, "An integer");


	例子1：
		  1-- static int  p =100；
		  2-- module_parm(p, int,0000);
		  3-- insmod xxx.ko p=200
	   
	例子2：数组
		  1-- static int array[2]= {-1, -1};
		  2-- static int arr_argc = 0;
		  3-- module_param_array (array, int, &arr_argc, 0000);
		  4-- MODULE_PARM_DESC (array, "An array of integers");  //modinfo

	{加、卸载函数中printk//显示内核缓冲区内容 dmesg}


【14】传参参数权限的意义：
      当参数的权限不为0时，在/sys/modules/模块名/parameters/下会生成一个和参数名同名的文件。
      应用层可以通过这个文件，来访问当前内核模块中的变量。


【15】多文件模块
（1） 1.c  2.c  ---> a.out
      gcc -c 1.c -o 1.o
      gcc -c 2.c -o 2.o
      ld  1.o 2.o -o a.out (gcc 1.o 2.o -o a.out)

（2）模块修改makefile
     obj-m := final.o
     final-objs :=init.o cleanup.o







 
   
  

